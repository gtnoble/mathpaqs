with Generic_Random_Functions,
     Generic_Real_Linear_Equations;

with Ada.Text_IO;
with Ada.Unchecked_Deallocation;

package body Copulas is

  package GRF is new Generic_Random_Functions(Real);
  package GRLE is new Generic_Real_Linear_Equations(Real, GRA);

  use GRF, GRLE;

  function Simulate(C: Independent_Copula; gen: Generator) return Real_Vector is
    r: Real_Vector(1..c.dim);
  begin
    -- Build an independent U(0,1) vector
    for z in r'Range loop
      r(z):= Real(Random(gen));
    end loop;
    return r;
  end Simulate;

  function Simulate(c: Gauss_Copula; gen: Generator) return Real_Vector is
    r: Real_Vector(1..c.dim);
    u1,u2, n1,n2: Real;
  begin
    -- Start with an independent U(0,1) vector
    for z in r'Range loop
      r(z):= Real(Random(gen));
    end loop;
    -- Treat the dimensions having dependencies
    for z in 1..c.dim_dep loop
      -- Normal N(0,1) are generated by pairs
      if z mod 2 = 1 then
        u1:= r(z);
        if z < c.dim_dep then
          u2:= r(z+1);
        else
          u2:= Real(Random(gen)); -- Fix 9-Nov-2010; was := u1 !!
        end if;
        Box_Muller(u1,u2, n1,n2);
        r(z):= n1;
      else
        r(z):= n2;
      end if;
    end loop;
    -- Now r is a draw of an independant Normal multivariate random variable.
    -- Apply the matrix (Quantitative Risk Management book: Algorithm 3.2)
    if c.dim_dep > 0 then
      r(1..c.dim_dep):= c.Sqrt_Correl_Matrix.all * r(1..c.dim_dep);
    end if;
    -- Now r is distributed as a dependant Normal
    for z in 1..c.dim_dep loop
      r(z):= Normal_CDF(r(z));
    end loop;
    -- Now r is U(0,1) with a Gaussian dependence on 1..dim_dep
    return r;
  end Simulate;

  procedure Dump(A: Real_Matrix; name: String) is
    use Ada.Text_IO;
    f: File_Type;
  begin
    Create(f, Out_File, name);
    for i in A'Range(1) loop
      for j in A'Range(2) loop
        Put(f, Real'Image(A(i,j)) & ';');
      end loop;
      New_Line(f);
    end loop;
    Close(f);
  end Dump;

  procedure Construct_as_Gauss(
    C   : out Copula_access;
    dim : Positive;
    corr: Real_Matrix
  )
  is
    g: Gauss_Copula(dim);
  begin
    g.Sqrt_Correl_Matrix:= new Real_Matrix'(Cholesky_Decomposition(corr));
    if trace then
      Dump(corr, "A.csv");
      Dump(g.Sqrt_Correl_Matrix.all, "L.csv");
    end if;
    g.dim_dep:= corr'Last(1);
    --
    c:= new Gauss_Copula'(g);
  end Construct_as_Gauss;

  procedure Dispose_internal is
    new Ada.Unchecked_Deallocation(Copula'Class, Copula_access);

  procedure Dispose(C: in out Copula_access) is
  begin
    Dispose_internal(C);
  end;

end Copulas;
